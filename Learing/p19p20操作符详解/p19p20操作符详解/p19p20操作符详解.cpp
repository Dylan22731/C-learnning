#include <stdio.h>
//创建一个结构体类型struct stu
struct stu
{
    //成员变量
    char name[20];
    int age;
    char id[20];
};

int main()
{
    //使用结构体类型struct stu创建一个对象s1，并初始化
    struct stu s1 = { "yxy",21,"20191130XX" };//集合就用大括号
    struct stu* ps = &s1;
    printf("%s\n", ps->name);//结构体指针->成员名
    printf("%d\n", ps->age);
    printf("%s\n",s1.name);
    printf("%d\n", s1.age);//结构体变量.成员名
    printf("%s\n", (*ps).age )//类似结构体变量.成员名
    return 0;
}


/*
操作符详解
分类:
算术操作符
移位操作符
位操作符
赋值操作符
单目操作符
关系操作符
逻辑操作符
条件操作符
逗号表达式
下标引用、函数调用和结构成员


算术操作符
+ - * / %
1.除了%操作符之外，其他的几个操作符可以作用于整数和浮点数。
2.对于/操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。例如5/2.0才能得到浮点数
3.%操作符的两个操作数必须为整数。返回的是整除之后的余数。

移位操作符
>>右移操作符
<<左移操作符

右移操作符:
1.算术右移（通常都是算术移位）//右移一位有÷2的效果。注意是有，但不全是，负数的情况特殊。
右边丢弃，左边补原符号位(0或1)
2.逻辑右移
右边丢弃，左边补0

左移操作符:
左边丢弃，右边补0//左移一位有*2的效果。注意是有，但不全是，负数的情况特殊。

知识补充：
整数的二进制表示有：原码、反码、补码
正整数中原码=反码=补码
负数中原码、反码、补码有一定的规则
储存到内存中的是补码
移位操作符移动的是补码！！！所以一定要注意负数的操作
以下以-1为例
100000000000000000000000000000001--原码
111111111111111111111111111111110--反码（符号位不变，其他全反过来）
111111111111111111111111111111111--补码（在反码的基础上+1）

#include <stdio.h>

int main()
{
    int a = 16;
    int b = a >> 1;
    printf("%d\n", b);
    //   >> --右移操作符
    //   移动的是二进制位
    //16=000000000000000000000000010000右移1位操作之后变成000000000000000000000000001000=8
}


位操作符
位操作符有:
&//按位与  按二进制位与 规则：两个数的二进制位相对应的情况下 ：有0为0 全1为1
|//按位或  规则：有1为1 全0为0
^//按位异或 规则：相同为0 相异为1
注:他们的操作数必须是整数。

#include <stdio.h>

int main()
{
    int a = 3;//000000000000000000000000000000011
    int b = 5;//000000000000000000000000000000101
    int c = a & b;//000000000000000000000000000000001
    int d = a | b;//000000000000000000000000000000111
    int e = a ^ b;//000000000000000000000000000000110
    printf("%d\n", c);
    return 0;
}

例题：交换 int a=3  int b=5的值，要求不添加任何新的临时变量。
加减法（缺陷是ab如果过于大，可能会溢出）
#include <stdio.h>

int main()
{
    int a = 3;
    int b = 5;
    a = a + b;
    b = a - b;
    a = a - b;
    printf("%d\n%d",a, b);
    return 0;
}

按位异或法
int main()
{
    int a = 3;
    int b = 5;
    a = a ^ b;//此时a相当于一个密码
    b = a ^ b;//b跟密码异或就能得到原来的a
    a = a ^ b;//此时b就是原来的a，然后a跟密码异或就能获得原来的b
    printf("%d\n%d",a, b);
    return 0;
}

练习：求一个整数存储在内存中的二进制中1的个数。
#include <stdio.h>

int main()
{
    int num = 0;
    int count = 0;
    int i = 0;
    scanf_s("%d", &num);
    for (i = 0; i < 32; i++)
    {
        if ((1 == ((num >> i) & 1)))
            count++;

    }
    printf("%d\n",count);
    return 0;
}


赋值操作符

赋值操作符是一个很棒的操作符，他可以让你得到一个你之前不满意的值。也就是你可以给自己重新赋值。
int weight = 120;//体重
weight = 89;//不满意就赋值
double salary = 10000.0;
salary = 20000.0;//使用赋值操作符赋值。


复合赋值符
+=
-+
*+
/=
%=
>>=
<<=
&=
|=
^=
例如
a= a+2;
a+=2;

a= a>>2;
a>>=2;


单目操作符(指对一个对象进行操作)//例如a++  -a这类
单目操作符有哪些呢?
! 逻辑反操作(将对象真假性对调操作)a为真  !a结果为假
- 负值
+ 正值

& 取地址
int* p= &a;//指针p类型为int*，作用是存放了a的地址
*p;//(解引用操作符)

sizeof 操作数的类型长度(以字节为单位)
~ 对一个数的二进制按位取反(01互换，对二进制中的补码进行作用)
-- 前置、后置--//
++ 前置、后置++//前置++是 指先++，再使用

例如：
int a =10;
printf("%d",++a);//先加到11再打印
最终结果就是11

* 间接访问操作符(解引用操作符)
(类型) 强制类型转换//例如：int a =(int)3.141;

知识补充：
数组的类型为int []
int arr[10] ={0};  类型为int [10]


关系操作符
>
>=
<
<=
!=用于测试“不相等”
==用于测试“相等”


逻辑操作符
&& 逻辑与
|| 逻辑或

360面试例题
#include <stdio.h>

int main()
{
    int i= 0,a=1,b=2,c=3,d=4;
    i = a++ || ++b || d++;//这里执行的情况为：先执行a，a为1为真，因为是逻辑或，后面都不再执行，但是a自己还会++，所以最终结果为2234。在逻辑或中，只要遇到真后面便不再执行。
    //i = a++ && ++b && d++;//这里执行的情况为：先执行a，a为0为假，因为是逻辑与，后面的都判断为假不再执行，但是a自己还会++，所以最终结果为1234。在逻辑与中，只有为真才会继续执行。
    printf("%d\n%d\n%d\n%d\n",a,b,c,d);
    return 0;
}


条件操作符(类似if else)
exp1? exp2:exp3

如b = ( a > 5 ? 3 ; -3)
#include <stdio.h>

int main()
{
    int a = 10;
    int b = 20;
    int max = 0;
    max=(a > b ? a: b);
    printf("%d\n",max);
    return 0;
}

逗号表达式
exp1，exp2，exp3，..expN
逗号表达式，就是用逗号隔开的多个表达式。逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。
int a=1;
int b=2;
int c = (a>b,a=b+10,a,b=a+1);//c最终为13 int c=b=a+1


下标引用、函数调用和结构成员

1.[]下标引用操作符
操作数:一个数组名+一个索引值
int arr[10];//创建数组
arr[9] =10;//[]的两个操作数是arr和9。

2.()函数调用操作符
接受一个或者多个操作数:第一个操作数是函数名，剩余的操作数就是传递给函数的参数。

3.访问一个结构的成员
结构体,成员名
>结构体指针->成员名

知识补充：结构体类型
#include <stdio.h>
//创建一个结构体类型struct stu
struct stu
{
    //成员变量
    char name[20];
    int age;
    char id[20];
};

int main()
{
    //使用结构体类型struct stu创建一个对象s1，并初始化
    struct stu s1 = { "yxy",21,"20191130XX" };//集合就用大括号
    struct stu* ps = &s1;
    printf("%s\n", ps->name);//结构体指针->成员名
    printf("%d\n", ps->age);
    printf("%s\n",s1.name);
    printf("%d\n", s1.age);//结构体变量.成员名
    printf("%s\n", (*ps).age )//类似结构体变量.成员名
    return 0;
}


学习操作符就是为了表达式求值，接下来内容相关表达式求值

表达式求值
表达式求值的顺序一部分是由操作符的优先级和结合性决定。
同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型。

隐式类型转换：整型提升和算术转换

整型提升的意义:
表达式的整型运算要在CPu的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。
因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。
通用CPU ( general-purpose CPU)是难以直接实现两个8比特字节直接相加运算（虽然机用指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int ,然后才能送入CPU去执行运算。

整型提升的规则：
整型提升是按照变量的数据类型的符号位来提升的
负数的整形提升char c1 = -1;
变量c1的二进制位(补码)中只有8个比特位:1111111
因为char为有符号的char
所以整形提升的时候，高位补充符号位,即为1
提升之后的结果是:
11111111111111111111111111111111

正数的整型提升char c2=l;
变量c2的二进制位(补码)中只有8个比特位:00000001
因为char为有符号的char
所以整形提升的时候,高位补充符号位，即为0
提升之后的结果是:
00000000000000000000000000000001

注意：char a =10//原本10的二进制有32位，但是存放在char数据类型中会被截断至只剩8位（因为char的占用空间只有1字节）



算术转换
如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就无法进行。
下面的层次体系称为寻常算术转换。
long double
double
f1oat
unsigned 1ong int
1ong int
unsigned int
int
如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算。
警告:但是算术转换要合理,要不然会有一些潜在的问题。


操作符的属性
复杂表达式的求值有三个影响的因素。
1.操作符的优先级
2.操作符的结合性（左到右、右到左）
3.是否控制求值顺序（例如逻辑或和逻辑与）
两个相邻的操作符先执行哪个?取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。例如：a=a+a*3
优先级结合性比特文件夹中有表（懒得查了）

某些操作符表达式就有问题
如：
int i =1;
int ret = (i++)+(i++)+(i++);
最后的结果在不同的编译器里是不同的数字，这是因为不知道i++与+的顺序。到底是3个4相加，还是2+3+4或者别的情况。



















*/